using System.Collections.Generic;
using System.Runtime.CompilerServices;

[assembly: InternalsVisibleTo("Slin.Masking.Tests")]
[assembly: InternalsVisibleTo("ApiMaskingSample")]

namespace Slin.Masking
{
    public interface IMaskingProfile : IMaskingOptions, IObjectMaskingOptions
    {

    }

    public interface IMaskingOptions
    {
        #region -- settings --
        /// <summary>
        /// default:"+*?[]|().\\^$"
        /// </summary>
        string RegexCheckChars { get; set; }

        /// <summary>
        /// Important: suggest ignore case. so default: true.
        /// </summary>
        bool KeyedMaskerPoolIgnoreCase { get; set; }

        /// <summary>
        /// default true. hashset will be enabled to keep the unmatched keys to skip 
        /// </summary>
        bool EnableUnmatchedKeysCache { get; set; }

        /// <summary>
        /// default 36, if 0, no check. Indicates if the matched key allowed or not by key's length, only takig effects when using KeyName is a regex pattern. 
        /// The purpsoe is don't want to make caching taking two much memory. Especially for those dynamic key names generated by program (I guess there might have such scenarios, although it's rare).
        /// It also applied for unmatched keys cache, when <see cref="EnableUnmatchedKeysCache"/> is enabled.
        /// </summary>
        int KeyNameLenLimitToCache { get; set; }
        #endregion

        List<UrlMaskingPattern> UrlMaskingPatterns { get; }

        /// <summary>
        /// named formatter definition is optional. It can be used to define formatter definitions, which be refer in <see cref="ValueFormatterDefinition"/> by Formatter.Name.
        /// </summary>
        Dictionary<string, ValueFormatterDefinition> NamedFormatters { get; set; }

        /// <summary>
        /// Masking rules contains rules, it can be named(key) or by specifying the key name. Key name supports regular expression. Like KeyName="^ssn|socialsecuritynumber$". If keyname is null, the name will be be used as keyname.
        /// </summary>
        Dictionary<string, MaskRuleDefinition> Rules { get; set; }

        /// <summary>
        /// normalize is optional, used to normalize the configurations, rules in the profile.
        /// </summary>
        void Normalize();
    }
}